mosys - The more open system tool

Introduction
------------
Mosys is designed to aid in obtaining obscure system-specific information
and present it in a uniform, human-friendly manner that is also parseable. It
is intended to complement other systems software and may overlap in some areas.

Examples of information this program is useful for:
- Platform identification
- Snapshot of machine information
- Listing non-enumerable devices
- Retrieving vital product data

Due to the system-specific nature of this program, it is unlikely to work with
most platforms. A generic subset of functionality will be available, though
its usefulness may be extremely limited.

Configuration & Building
------------------------
Mosys uses the Meson build system. Run "meson -D${arch?} output_dir" to
configure and then "ninja -C output_dir" to build. "ninja -C output_dir test"
will run tests and "ninja -C output_dir install" will install. Chrome OS
contributors will want to use cros_workon instead.

See meson.build for valid arch options.

Other flags of interest:
-Duse_cros_config=true/false: whether to enable linking to cros_config for
                              Chrome OS. See Chrome OS example in mosys ebuild.

Note that you might have better luck compiling mosys with Clang while -Werror is
enabled. This is because we (Chromium) use Clang as our default compiler. To do
that, add CC=clang before you invoke Meson.

In summary, all of this should look something like:
  CC=clang meson -Darch=amd64 -Duse_cros_config=true out
  ninja -C out
  ninja -C out test
  ninja -C out install

To build the experimental Rust support, first build libmosys.a using the
instructions above. Then run: "MESON_BUILD_ROOT=output_dir cargo build".

To run tests:
  CC=clang meson -Darch=amd64 -Duse_cros_config=true -Dtest_cros_config=true out
  ninja -C out
  USE=unibuild MESON_BUILD_ROOT=out cargo test

Usage
-----
Mosys uses a natural language syntax to navigate thru a command hierarchy for
a given platform. Each supported platform will have a specific set of commands
available.

Typically, top-level commands will reflect classes of hardware components
such as "cpu" or "sensor", available busses such as "pci" or "i2c", or a
type of information such as "smbios" or "vpd".

Mosys returns EXIT_SUCCESS upon successful completion of a command, or
EXIT_FAILURE if a command is not supported on a given platform. These values
are defined in the system's stdlib.h. In case of failure, mosys will also print
a message to stderr to let the user know.

Use "mosys -t" to display the command tree for the host platform.

Debugging
---------
Mosys uses a minijail to restrict behavior. This can sometimes restrict desired
behavior, especially system calls not whitelisted by the seccom filter.
If a subcommand is returning with an error that should be passing, this might
be why. In order to debug this, run seccomp_debug.sh with the failing command.
This will print out the system calls that caused the run to fail.

Ex. 'mosys platform id' failing on DUT
On the DUT, copy over seccomp_debug.sh and run:
  ./seccomp_debug.sh mosys platform id
